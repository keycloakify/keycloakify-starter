import * as fs from "fs";
import {
    join as pathJoin,
    relative as pathRelative,
    dirname as pathDirname,
    sep as pathSep
} from "path";
import { assert } from "tsafe/assert";
import { same } from "evt/tools/inDepth";
import { crawl } from "keycloakify/src/bin/tools/crawl";
import { downloadKeycloakDefaultTheme } from "../shared/downloadKeycloakDefaultTheme";
import { getThisCodebaseRootDirPath } from "../tools/getThisCodebaseRootDirPath.overridable";
import { deepAssign } from "keycloakify/src/tools/deepAssign";
import propertiesParser from "properties-parser";
import { keycloakifyExtraMessages, THEME_NAME } from "./generateI18nMessages.overridable";
import { runPrettier } from "keycloakify/src/bin/tools/runPrettier";

export async function generateI18nMessages() {
    type Dictionary = { [idiomId: string]: string };

    const messages: { [language: string]: Dictionary } = {};

    const { extractedDirPath } = await downloadKeycloakDefaultTheme();

    {
        const baseThemeDirPath = pathJoin(extractedDirPath, "base");
        const re = new RegExp(
            `^([^\\${pathSep}]+)\\${pathSep}messages\\${pathSep}messages_([^.]+).properties$`
        );

        crawl({
            dirPath: baseThemeDirPath,
            returnedPathsType: "relative to dirPath"
        }).forEach(filePath => {
            const match = filePath.match(re);

            if (match === null) {
                return;
            }

            const [, themeType_here, language] = match;

            if (themeType_here !== THEME_NAME) {
                return;
            }

            messages[language.replace(/_/g, "-")] = Object.fromEntries(
                Object.entries(
                    propertiesParser.parse(
                        fs.readFileSync(pathJoin(baseThemeDirPath, filePath)).toString("utf8")
                    ) as Record<string, string>
                )
                    .map(([key, value]) => [key, value.replace(/''/g, "'")])
                    .map(([key, value]) => [key === "locale_pt_BR" ? "locale_pt-BR" : key, value])
                    .map(([key, value]) => [key, key === "termsText" ? "" : value])
            );
        });
    }

    const languages = Object.keys(messages);

    assert(
        same(languages, Object.keys(keycloakifyExtraMessages), {
            takeIntoAccountArraysOrdering: false
        })
    );

    deepAssign({
        target: messages,
        source: keycloakifyExtraMessages
    });

    const messagesDirPath = pathJoin(
        getThisCodebaseRootDirPath(),
        "src",
        "core",
        "i18n",
        "messages_defaultSet"
    );

    fs.rmSync(messagesDirPath, {
        recursive: true,
        force: true
    });

    fs.mkdirSync(messagesDirPath, { recursive: true });

    {
        const filePath = pathJoin(messagesDirPath, "types.ts");

        let sourceCode = [
            ``,
            `export const languageTags = ${JSON.stringify(languages, null, 2)} as const;`,
            ``,
            `export type LanguageTag = typeof languageTags[number];`,
            ``,
            `export type MessageKey = keyof typeof import("./en")["default"];`,
            ``
        ].join("\n");

        sourceCode = await runPrettier({
            sourceCode,
            filePath
        });

        fs.writeFileSync(filePath, Buffer.from(sourceCode, "utf8"));
    }

    const generatedFileHeader = [
        `//This code was automatically generated by running ${pathRelative(
            getThisCodebaseRootDirPath(),
            __filename
        )}`,
        "//PLEASE DO NOT EDIT MANUALLY"
    ].join("\n");

    await Promise.all(
        languages.map(async language => {
            const filePath = pathJoin(messagesDirPath, `${language}.ts`);

            fs.mkdirSync(pathDirname(filePath), { recursive: true });

            let sourceCode = [
                generatedFileHeader,
                "",
                "/* spell-checker: disable */",
                `const messages= ${JSON.stringify(messages[language], null, 2)};`,
                "",
                "export default messages;",
                "/* spell-checker: enable */"
            ].join("\n");

            sourceCode = await runPrettier({
                sourceCode,
                filePath
            });

            fs.writeFileSync(filePath, Buffer.from(sourceCode, "utf8"));
        })
    );

    {
        const filePath = pathJoin(messagesDirPath, "index.ts");

        let sourceCode = [
            generatedFileHeader,
            `import * as en from "./en";`,
            "",
            "export async function fetchMessages_defaultSet(currentLanguageTag: string) {",
            "    const { default: messages_defaultSet } = await (() => {",
            "        switch (currentLanguageTag) {",
            `            case "en": return en;`,
            ...languages
                .filter(language => language !== "en")
                .map(language => `            case "${language}": return import("./${language}");`),
            '            default: return { "default": {} };',
            "        }",
            "    })();",
            "    return messages_defaultSet;",
            "}"
        ].join("\n");

        sourceCode = await runPrettier({
            sourceCode,
            filePath
        });

        fs.writeFileSync(filePath, Buffer.from(sourceCode, "utf8"));
    }
}
